## 퀵정렬

pivot(중심축) 을 정하고, 중심축 보다 작은 값들은 왼쪽으로 큰 값들은 오른쪽으로 보내는 것이다.

이렇게 pivot을 정해서 왼쪽 오른쪽으로 나누고 다시금 왼쪽 오른쪽에 대해 재귀적으로 pivot을 정해서 왼쪽 오른쪽을 나누고,, 이 과정을 반복하면 결국 정렬이 완성 된다.

### 퀵정렬 알고리즘의 구체적인 개념

- 하나의 리스트를 피벗(pivot)을 기준으로 두 개의 비균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.

퀵 정렬은 n개의 데이터를 정렬할 때, 최악의 경우에는 O(n^2)번의 비교를 수행하고, 평균적으로 O(n log n)번의 비교를 수행한다.

- 퀵 정렬은 3단계로 이루어져있다.

1단계. 분할 : 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽 = 피벗보다 작은 요소들, 오른쪽 = 피벗보다 큰 요소들)로 분할한다.

2단계. 정복(Conquer) : 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 방법을 적용한다.

3단계. 결합(Combine) : 정렬된 부분 배열들을 하나의 배열에 합병한다.

- 순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다

### 알고리즘

- 퀵 정렬 알고리즘
    - 피벗을 기준으로 왼쪽 리스트와 오른쪽 리스트로 나누기 위해 함수를 호출한다.
    - 왼쪽 리스트와 오른쪽 리스트 각각 quick_sort() 함수를 호출한다.
    
- 퀵 정렬 알고리즘 :
    1. 피벗을 정하여 왼쪽부터 시작하는 low와 오른쪽부터 시작하는 high 변수를 선언한다.
    2. low 변수는 arr[low] 값이 피벗보다 작으면 계속 증가한다.
    3. high 변수는 arr[high] 값이 피벗보다 크면 계속 감소한다.
    4. high가 low보다 크면 arr[low]와 arr[high] 값을 바꾸어주고 2~4번을 반복한다
    5. high가 low보다 작으면 피벗과 arr[high] 값을 교환하여 피벗이 기준이 되게 만든다.

## 수도코드

```
1. 먼저, 배열의 길이가 1과 같거나 작게 될 경우 배열을 바로 리턴한다.

2. 리스트 가운데 하나의 원소를 고르고 pivot 이라고 한다. : 첫번째 인덱스를 pivot으로 정했다.

3. 배열 안에서 pivot을 제외한 모든 요소를 탐색해서 pivot보다 작으면 left, 크면 right라는 배열에 넣는다.

        -> let left = []; let right = [];

        -> 이 과정은 인덱스가 arr.length만큼 반복한다

4. left와 right에 값이 모두 넣어졌으면 각각의 배열에 대해 quickSort를 재귀하도록 해서 다시 정렬한다.

5. left, pivot, right를 합쳐서 리턴한다.
```

```jsx
const quickSort = function (arr) {
  if (arr.length <= 1) return arr;

  const pivot = arr[0];
  const left = [];
  const right = [];

  for (let i = 1; i < arr.length; i++) {
    if (arr[i] <= pivot) left.push(arr[i]);
    else right.push(arr[i]);
  }

  const lSorted = quickSort(left);
  const rSorted = quickSort(right);
  return [...lSorted, pivot, ...rSorted];
};
```
